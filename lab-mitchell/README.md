# Lab 12 ~ Express Middleware

**Author**: Mitchell
**Version**: 1.0.0

## Overview
We were tasked to create an HTTP server using the `express` NPM package. After learning how `express` works beneath the hood, it is wonderful to now have it helping out with the heavy lifting. We needed to create an object constructor that creates a simple resource for us with 3 properties, and I chose the simple model of student names and cities of residence. The properties on the constructed student objects are `name`, `city`, and a `._id` generated by the `UUID` NPM package. 

This application leverages the `body-parser` NPM package to parse the request body on `POST` and `PUT` routes. We also included the `debug` NPM module to assist developers in understanding what is happening with these requests, where, and to elicit deeper knowledge of the application overall. The application also utilizes a storage module and file system persistence through the use of the `fs` NodeJS module.

## Getting Started
To get this application up and running, fork and/or clone this repository using the `git clone <git repository link>` command in your terminal. Next, run the `npm install` command, which will install all the necessary dependencies in the accompanying package.json file. After those packages have installed, you can run `npm test` to explore the included tests and functionality of their respective solutions. You can open up the code in your favorite editor to explore/modify the code, see how the tests are structured, and create tests of your own if desired. `npm start` will start a nodemon server from the index.js entry point. `npm run test:debug` will include debugger information when viewing the included tests. `npm run start:debug` will start up the nodemon server like `npm start`, but with the addition of debugger flags in the console.

## Description
**Modules**
* `server.js` in the lib/ directory is the server for this application. It utilizes `cors` and `express` to get a server up/running, utilizes the routing functionality from another module, and exports a server instance for use in other modules. It has two methods, `server.start(port, callback)` and `server.stop(callback)` attached to the exported object. `server.start` expects a port and callback arguments, and starts a server instance on the specified port. If there is an instance already running, it will return an error explaining this. `server.stop` expects a single callback argument, and will close the server instance. If it is called when the server instance is already closed, it will return an error explaining this.

* `student.js` is in the lib/ directory and exports a single anonymous function that creates new student objects to be stored in the data/student/ directory. It expects two arguments, name and city, and uses those arguments to assign properties to the student instance as well as `uuid` to create a unique ID for each instance. It returns a Promise, and upon successful creation returns a Promise resolve containing the new instance to be passed to other modules.

* `route-student.js` in the route/ directory is the router for this application. It exports a single anonymous function that excepts a `router` argument, and contains the different CRUD method routing for HTTP endpoint requests. It handles GET/POST/PUT/DELETE requests, and calls the various storage functions required for those requests to be made, data stored, and responses for the end user received. It can handle GET requests with an endpoint of `/api/v1/student/<record id>` to return a single record, GET requests with an enpoint of `/api/v1/student/` (optional / after student) to return an array of all IDs currently stored. Both of these will return a status code of `200` on success. POST requests to `/api/v1/student name='<string here, quote if spaces>' city='<string here, quotes if spaces>'` and will store a new record with a unique ID, and return that object to the user with a `201` status code on success. PUT requests are in the form of `/api/v1/student/<record id> name='<new name string>' city='<new city string>'`, and return a status code `204` on success. It is alright to only enter a single record property (name or city) as well. DELETE requests to `/api/v1/student/<record id>` will return a status code of `204` on success. For all these requests, the error handler module will inform user of errors as described below.

* `storage.js` in the lib/ directory utilizes `fs` and `bluebird` to promisify the `fs` module. It exports a storage object with multiple CRUD methods attached to it. All of these methods are utilized in the above `route-student.js` module. `storage.create(schema, id, item)` takes a passed schema, in this case `'student'` to target the student/ directory in the data/ directory for storage, a unique `id` which is created by `uuid`, and an item to store in JSON format. `storage.fetchOne(schema, id)` takes the target schema and ID to return a record. `storage.fetchAll(schema)` takes only the target schema and returns all IDs with that schema. `storage.destroy(schema, id)` takes the target schema and ID and removes that record from storage. `storage.update(schema, id, item)` takes the target schema, ID, and properties of the record to be updated in JSON format and updates that record. All responses to the user are described in the respective modules.

* `error-handler.js` in the /lib directory is the custom error-handler for this application. It exports a single anonymous function, expecting error and response as arguments. This module has multiple switch cases to handle different error types. If the error message return from elsewhere in the application includes `validation error`, the function will return a response with a status of `400` and send the error name and message along with it. If the error it receives includes `path error`, it will return a response with a status of `404` and send the error name and message along with it. If the error it receives includes `enoent`, it will return a response with a status of `404` and send the error name and message along with it. If none of these cases occur, it will default to return a response with a status of `500` and send the error name and message along with it. During routing operations, if there is malformed data being sent with HTTP requests, the error-handler will serve status code `400` errors. If the specified record is not found, or is improperly entered, the error-handler will serve status code `404` errors.


## Credits and Collaborations
[Body Parser Docs](https://www.npmjs.com/package/body-parser) ~ https://www.npmjs.com/package/body-parser
[Bluebird Docs](http://bluebirdjs.com/docs/api/promise.promisify.html) ~ http://bluebirdjs.com/docs/api/promise.promisify.html
[Dotenv Docs](https://www.npmjs.com/package/dotenv) ~ https://www.npmjs.com/package/dotenv
[Express Docs](http://expressjs.com/en/4x/api.html) ~ http://expressjs.com/en/4x/api.html
[FS Docs](https://nodejs.org/dist/latest-v9.x/docs/api/fs.html) ~ https://nodejs.org/dist/latest-v9.x/docs/api/fs.html
[Jest Docs](https://facebook.github.io/jest/) ~ https://facebook.github.io/jest/
[UUID Docs](https://www.npmjs.com/package/uuid) ~ https://www.npmjs.com/package/uuid